# IndependentWork12  
## Тема: PLINQ — дослідження продуктивності та безпеки  
### Автор: *[Твоє ім'я]*  
### Група: *[тут встав групу]*  

## Мета роботи
Дослідити переваги та недоліки PLINQ (Parallel LINQ) у порівнянні зі звичайним LINQ, виміряти продуктивність на різних обсягах даних та розглянути можливі проблеми потокобезпечності при паралельній обробці колекцій.

## Використані матеріали
- PLINQ (Microsoft Docs)  
- When to use PLINQ  
- PLINQ Side Effects  
- Stopwatch (Microsoft Docs)  
- Матеріали з Google Classroom  

# Хід роботи

## 1️Створення консолного проєкту  
Створено проєкт **IndependentWork12** у Visual Studio.

## 2️Генерація великих наборів даних  
Була створена колекція `List<int>` з розмірами:

- **1 000 000**
- **5 000 000**
- **10 000 000** елементів

Елементи заповнювалися випадковими числами від 1 до 1 000 000.

## 3️Реалізація обчислювально інтенсивної операції  

Для кожного числа виконувалося:

- фільтрація (x > 1000, x непарне);
- перевірка на просте число (ділення до sqrt(n));
- додаткові математичні обчислення (Math.Sqrt, Sin, Cos у циклі).

Це навантажує CPU і дозволяє коректно протестувати переваги PLINQ.

## 4️Порівняння продуктивності LINQ vs PLINQ  

### Методики:
- **LINQ** — звичайне послідовне виконання.  
- **PLINQ** — `.AsParallel()` з примусовою паралелізацією.

### Вимірювання часу:
Для вимірів використовувався `System.Diagnostics.Stopwatch`.

### РЕЗУЛЬТАТИ (встав свої значення):

| Кількість елементів | LINQ (мс) | PLINQ (мс) | Різниця |
|--------------------|-----------|------------|----------|
| 1 000 000          | ____ мс   | ____ мс    | ____     |
| 5 000 000          | ____ мс   | ____ мс    | ____     |
| 10 000 000         | ____ мс   | ____ мс    | ____     |

## Аналіз продуктивності

### Коли PLINQ швидший?
- при **великих обсягах даних (5M–10M)**;
- при **важких обчисленнях**, які добре розподіляються між ядрами CPU.

Причина: паралельність дає реальний приріст лише коли роботи багато.

### Коли LINQ може бути швидшим?
- при малих колекціях;
- коли операція над елементом **дешева**;
- коли накладні витрати PLINQ (планування потоків, злиття результатів) більші, ніж вигода.

# Дослідження проблем безпеки (побічні ефекти)

Було створено приклад з модифікацією спільної змінної всередині PLINQ:

### Неправильний код:
```csharp
int wrongSum = 0;
data.AsParallel().ForAll(x => wrongSum += x);
